<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•¸å­¸æˆ°æ£‹</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Microsoft JhengHei", sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #app {
            width: 100%;
            max-width: 1200px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: row;
            gap: 20px;
        }

        .game-title {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 24px;
            width: 100%;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
            width: 70%;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(5, 60px);
            grid-template-rows: repeat(6, 60px);
            gap: 5px;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 8px;
            position: relative;
        }

        .board-cell {
            width: 60px;
            height: 60px;
            border: 1px solid #999;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            background: white;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.2s;
        }

        .board-cell:hover {
            background: #e0e0e0;
        }

        .status-bar {
            font-size: 18px;
            margin-bottom: 10px;
            padding: 10px;
            background: #eee;
            border-radius: 5px;
            text-align: center;
            width: 100%;
        }

        .selected {
            background: #ffeb3b !important;
        }

        .moveable {
            background: #4CAF50 !important;
            color: white;
        }

        .attackable {
            background: #f44336 !important;
            color: white;
        }

        .problem-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .problem-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            width: 80%;
            max-width: 500px;
        }

        .question {
            font-size: 24px;
            margin: 20px 0;
        }

        .options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .option-btn {
            padding: 10px 20px;
            font-size: 18px;
            border: none;
            border-radius: 5px;
            background: #2196f3;
            color: white;
            cursor: pointer;
            transition: background 0.2s;
        }

        .option-btn:hover {
            background: #1976d2;
        }

        .level-select {
            padding: 20px;
            text-align: center;
            width: 100%;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .level-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .level-card:hover {
            transform: translateY(-5px);
        }

        .level-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .level-card.current {
            border: 2px solid #2196f3;
        }

        .menu-btn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .menu-btn:hover {
            background: #1976d2;
        }

        /* è¡€é‡æ¢æ¨£å¼ */
        .health-bar {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            margin-top: 2px;
        }

        .health-bar-fill {
            height: 100%;
            background: #76ff03;
            transition: width 0.3s;
        }

        /* ç‰¹æ•ˆæ¨£å¼ */
        .special-effect {
            position: absolute;
            font-size: 24px;
            pointer-events: none;
        }

        /* é­”æ³•é¸å–®æ¨£å¼ */
        .magic-menu {
            margin-top: 10px;
        }

        .magic-btn {
            margin: 5px;
            padding: 10px 15px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            background: #ff9800;
            color: white;
            cursor: pointer;
            transition: background 0.2s;
        }

        .magic-btn:hover {
            background: #fb8c00;
        }

        /* éŠæˆ²çµæŸæ¨£å¼ */
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff3cd;
            padding: 20px;
            border: 2px solid #ffeeba;
            border-radius: 10px;
            text-align: center;
            z-index: 4000;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="game-container">
            <h1 class="game-title">æ•¸å­¸æˆ°æ£‹</h1>

            <!-- èªªæ˜é¢æ¿ -->
            <div class="instructions">
                <h3>éŠæˆ²èªªæ˜</h3>
                <p>1. éŠæˆ²é–‹å§‹å‰è«‹é¸æ“‡ä¸€å€‹é—œå¡ã€‚</p>
                <p>2. é»æ“Šè§’è‰²é¡¯ç¤ºå¯ç§»å‹•çš„ç¶ è‰²æ ¼å­ï¼Œç§»å‹•åˆ°ç›®æ¨™ä½ç½®ã€‚</p>
                <p>3. ç•¶è§’è‰²ç§»å‹•åˆ°æœ‰æ€ªç‰©çš„æ ¼å­æ™‚ï¼Œå°‡è§¸ç™¼æ•¸å­¸é¡Œç›®ï¼Œç­”å°å³å¯æ”»æ“Šæ€ªç‰©ã€‚</p>
                <p>4. ç­”éŒ¯å‰‡å¤±å»ç”Ÿå‘½å€¼ï¼Œç”Ÿå‘½å€¼æ­¸é›¶å‰‡éŠæˆ²çµæŸã€‚</p>
                <p>5. ç´¯ç©ç¶“é©—å€¼å¾Œï¼Œè§’è‰²å¯ä»¥å‡ç´šï¼š</p>
                <ul>
                    <li>å°å…µ (0-49ç¶“é©—å€¼)ï¼šåŸºæœ¬æ”»æ“Š</li>
                    <li>æ³•å¸«å­¸å¾’ (50-99ç¶“é©—å€¼)ï¼š20%æ©Ÿç‡é€ æˆæš´æ“Š(2å€å‚·å®³)</li>
                    <li>å¤§æ³•å¸« (100ç¶“é©—å€¼ä»¥ä¸Š)ï¼š30%æ©Ÿç‡æš´æ“Šã€æ¯æ¬¡æ”»æ“Šæ¢å¾©10é»ç”Ÿå‘½å€¼</li>
                </ul>

                <!-- é­”æ³•é¸å–® -->
                <div class="magic-menu">
                    <button class="magic-btn" @click="castSpell('heal')">æ²»ç™‚</button>
                    <button class="magic-btn" @click="castSpell('fireball')">ç«çƒè¡“</button>
                    <button class="magic-btn" @click="castSpell('lightning')">é–ƒé›»è¡“</button>
                </div>
            </div>

            <!-- é—œå¡é¸æ“‡ç•«é¢ -->
            <div v-if="gameState.showLevelSelect">
                <h2>é¸æ“‡é—œå¡</h2>
                <div class="level-grid">
                    <div v-for="level in levels" 
                         :key="level.id"
                         class="level-card"
                         :class="{
                             'locked': !gameState.unlockedLevels.includes(level.id),
                             'current': gameState.currentLevel === level.id
                         }"
                         @click="handleLevelSelect(level.id)"
                         :disabled="!gameState.unlockedLevels.includes(level.id)">
                        <h3>{{ level.name }}</h3>
                        <p>é›£åº¦ï¼š{{ level.difficulty }}</p>
                        <p v-if="level.requiredScore > 0">
                            éœ€è¦ {{ level.requiredScore }} åˆ†è§£é–
                        </p>
                    </div>
                </div>
                <div class="character-info">
                    <h3>è§’è‰²ç‹€æ…‹</h3>
                    <p>ç­‰ç´šï¼š{{ characterState.level }}</p>
                    <p>ç¶“é©—å€¼ï¼š{{ characterState.exp }}/100</p>
                    <p>è·æ¥­ï¼š{{ characters[characterState.type].name }}</p>
                    <p>é‡‘å¹£ï¼š{{ playerState.gold }}</p>
                    <p>é“å…·ï¼š{{ playerState.items.join(', ') || 'ç„¡' }}</p>
                </div>
            </div>

            <!-- éŠæˆ²é€²è¡Œç•«é¢ -->
            <div v-else>
                <div class="status-bar">
                    HP: {{ playerState.hp }} | åˆ†æ•¸: {{ playerState.score }} | é‡‘å¹£: {{ playerState.gold }}
                    <div class="timer" v-if="timerActive">å€’è¨ˆæ™‚ï¼š{{ timer }}</div>
                </div>
                <div v-if="gameState.isGameOver" class="game-over">
                    {{ gameState.message }}
                    <button @click="initLevel(gameState.currentLevel)" class="menu-btn">
                        é‡æ–°æŒ‘æˆ°
                    </button>
                </div>
                <div class="game-board">
                    <div v-for="(row, rowIndex) in gameBoard" 
                         :key="rowIndex" 
                         class="board-row">
                        <div v-for="(cell, colIndex) in row" 
                             :key="colIndex"
                             class="board-cell"
                             :class="{
                                 'selected': selectedPosition && selectedPosition[0] === rowIndex && selectedPosition[1] === colIndex,
                                 'moveable': moveablePositions.some(([r, c]) => r === rowIndex && c === colIndex),
                                 'attackable': attackablePositions.some(([r, c]) => r === rowIndex && c === colIndex)
                             }"
                             @click="handleCellClick(rowIndex, colIndex)">
                            <div class="cell-content">
                                {{ cell }}
                                <div v-if="isMonster(cell)" class="health-bar">
                                    <div class="health-bar-fill" 
                                         :style="{ width: (monsters[cell].hp / monsters[cell].maxHp) * 100 + '%' }">
                                    </div>
                                </div>
                                <div v-if="isNPCCell(cell)" class="health-bar">
                                    <div class="health-bar-fill" style="background: #4CAF50;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <button @click="gameState.showLevelSelect = true" class="menu-btn">
                    è¿”å›é¸å–®
                </button>
            </div>

            <!-- å•é¡Œå½ˆçª— -->
            <div v-if="showProblem" class="problem-modal">
                <div class="problem-content">
                    <h3>è§£ç­”ä¸‹åˆ—é¡Œç›®ï¼š</h3>
                    <p class="question">{{ currentProblem.question }}</p>
                    <div class="options">
                        <button 
                            v-for="option in currentProblem.options" 
                            :key="option"
                            @click="handleAnswer(option, $event)"
                            class="option-btn">
                            {{ option }}
                        </button>
                    </div>
                </div>
            </div>

            <!-- è§’è‰²ä¿¡æ¯ -->
            <div class="character-info">
                <h3>è§’è‰²ç‹€æ…‹</h3>
                <p>ç­‰ç´šï¼š{{ characterState.level }}</p>
                <p>ç¶“é©—å€¼ï¼š{{ characterState.exp }}/100</p>
                <p>è·æ¥­ï¼š{{ characters[characterState.type].name }}</p>
                <p>é‡‘å¹£ï¼š{{ playerState.gold }}</p>
                <p>é“å…·ï¼š{{ playerState.items.join(', ') || 'ç„¡' }}</p>
            </div>

            <!-- ç‰¹æ•ˆé¡¯ç¤º -->
            <div v-for="effect in effectSystem.effects" 
                 :key="effect.id"
                 class="special-effect"
                 :style="effect.style">
                {{ effect.text }}
            </div>
        </div>
    </div>

    <script>
        const app = Vue.createApp({
            setup() {
                const { ref, reactive, computed } = Vue;

                // é—œå¡è¨­å®š
                const LEVELS = [
                    {
                        id: 1,
                        name: 'åˆå­¸è€…çš„è©¦ç…‰',
                        map: [
                            ['ğŸ‘¶', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾'],
                            ['â¬œ', 'ğŸ‘¾', 'â¬œ', 'â¬œ', 'â¬œ'],
                            ['â¬œ', 'â¬œ', 'â¬œ', 'â¬œ', 'â¬œ'],
                            ['â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'â¬œ'],
                            ['ğŸ‘¾', 'â¬œ', 'â¬œ', 'â¬œ', 'ğŸ']
                        ],
                        difficulty: 'easy',
                        requiredScore: 0,
                        mission: 'æ‰“æ•—2éš»ğŸ‘¾'
                    },
                    {
                        id: 2,
                        name: 'é€²éšæŒ‘æˆ°',
                        map: [
                            ['ğŸ‘¶', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾'],
                            ['ğŸ‘¾', 'â¬œ', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'â¬œ'],
                            ['â¬œ', 'ğŸ‘¾', 'â¬œ', 'â¬œ', 'ğŸ‘¾', 'ğŸ‘¾', 'â¬œ'],
                            ['â¬œ', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'ğŸ‘¾', ''],
                            ['ğŸ‘¾', 'â¬œ', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'â¬œ', 'â¬œ'],
                            ['â¬œ', 'ğŸ‘¾', 'â¬œ', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ']
                        ],
                        difficulty: 'medium',
                        requiredScore: 100,
                        mission: 'è§£æ•‘1åæ‘æ°‘'
                    },
                    {
                        id: 3,
                        name: 'å¤§å¸«ç´šè€ƒé©—',
                        map: [
                            ['ğŸ§™', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾'],
                            ['â¬œ', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'â¬œ'],
                            ['ğŸ‘¾', 'â¬œ', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾'],
                            ['â¬œ', 'ğŸ‘¾', 'â¬œ', 'â¬œ', 'ğŸ‘¾', 'ğŸ‘¾', 'ğŸ', 'ğŸ‘¾'],
                            ['ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'ğŸ‘¾'],
                            ['â¬œ', 'ğŸ‘¾', 'â¬œ', 'â¬œ', 'ğŸ‘¾', 'â¬œ', 'ğŸ‘¾', 'ğŸ']
                        ],
                        difficulty: 'hard',
                        requiredScore: 300,
                        mission: 'æ‰“æ•—5éš»ğŸ‘¾ä¸¦è§£æ•‘2åæ‘æ°‘'
                    }
                ];

                // éŠæˆ²é¢æ¿
                const gameBoard = ref([]);

                // ç•¶å‰é¸ä¸­çš„ä½ç½®
                const selectedPosition = ref(null);

                // ç•¶å‰å•é¡Œ
                const currentProblem = ref(null);

                // æ˜¯å¦é¡¯ç¤ºå•é¡Œ
                const showProblem = ref(false);

                // ç•¶å‰æ€ªç‰©
                const currentMonster = ref(null);

                // æ€ªç‰©è³‡æ–™
                const monsters = reactive({
                    'ğŸ‘¾': { name: 'å“¥å¸ƒæ—', hp: 30, maxHp: 30, damage: 10, type: 'goblin', exp: 10 },
                    'ğŸ‰': { name: 'é¾', hp: 50, maxHp: 50, damage: 20, type: 'dragon', exp: 20 }
                });

                // NPCæ–™
                const npcs = reactive([
                    { name: 'æ‘æ°‘A', position: [2, 2], isRescued: false },
                ]);

                // è§’è‰²è³‡æ–™
                const characters = reactive({
                    'ğŸ‘¶': { name: 'å°å…µ', moveRange: 1, hp: 80, exp: 0 },
                    'ğŸ§™â€â™‚ï¸': { name: 'æ³•å¸«å­¸å¾’', moveRange: 1, hp: 100, exp: 50 },
                    'ğŸ§™': { name: 'å¤§æ³•å¸«', moveRange: 1, hp: 120, exp: 100 }
                });

                // ç©å®¶è§’è‰²ç‹€æ…‹
                const characterState = reactive({
                    type: 'ğŸ‘¶',
                    exp: 0,
                    level: 1
                });

                // ç©å®¶ç‹€æ…‹
                const playerState = reactive({
                    hp: characters['ğŸ‘¶'].hp,
                    score: 0,
                    gold: 0,
                    items: []
                });

                // éŠæˆ²ç‹€æ…‹
                const gameState = reactive({
                    currentLevel: 1,
                    isGameOver: false,
                    isWin: false,
                    message: '',
                    showLevelSelect: true,
                    unlockedLevels: [1],
                    totalScore: 0,
                    missionCompleted: false
                });

                // ä»»å‹™ç‹€æ…‹
                const missionState = reactive({
                    currentMission: '',
                    objectives: 0,
                    target: '',
                    isCompleted: false,
                    requiredCount: 0
                });

                // æ–¹æ³•ï¼šåˆå§‹åŒ–ä»»å‹™
                const initializeMission = () => {
                    const level = LEVELS.find(l => l.id === gameState.currentLevel);
                    if (!level) return;
                    
                    missionState.currentMission = level.mission;
                    missionState.objectives = 0;
                    missionState.isCompleted = false;
                    missionState.target = level.mission.includes('æ‰“æ•—') ? 'ğŸ‘¾' : 'æ‘æ°‘';
                    
                    // å¾ä»»å‹™æè¿°ä¸­æå–æ‰€éœ€æ•¸é‡
                    const matches = level.mission.match(/\d+/);
                    missionState.requiredCount = matches ? parseInt(matches[0]) : 1;
                };

                // è¨ˆæ™‚å…ƒç´ 
                const timer = ref(30);
                const timerActive = ref(false);
                let timerInterval = null;

                // å¯ç§»å‹•ä½ç½®è¨ˆç®—
                const moveablePositions = computed(() => {
                    if (!selectedPosition.value) return [];
                    const [row, col] = selectedPosition.value;
                    const positions = [];
                    const range = characters[characterState.type].moveRange;
                    
                    // æª¢æŸ¥ä¸Šä¸‹å·¦å³åŠå°è§’ç·šæ–¹å‘
                    const directions = [
                        [-1, 0], [1, 0], [0, -1], [0, 1],
                        [-1, -1], [-1, 1], [1, -1], [1, 1]
                    ];
                    for (const [dx, dy] of directions) {
                        for (let i = 1; i <= range; i++) {
                            const newRow = row + dx * i;
                            const newCol = col + dy * i;
                            if (newRow >= 0 && newRow < gameBoard.value.length && 
                                newCol >= 0 && newCol < gameBoard.value[0].length) {
                                if (gameBoard.value[newRow][newCol] === 'â¬œ' || 
                                    gameBoard.value[newRow][newCol] === 'ğŸ') {
                                    positions.push([newRow, newCol]);
                                } else {
                                    break; // é‡åˆ°éšœç¤™ç‰©åœæ­¢å»¶ä¼¸
                                }
                            }
                        }
                    }
                    return positions;
                });

                // å¯æ”»æ“Šä½ç½®è¨ˆç®—
                const attackablePositions = computed(() => {
                    if (!selectedPosition.value) return [];
                    const [row, col] = selectedPosition.value;
                    const positions = [];
                    
                    // æª¢æŸ¥ä¸Šä¸‹å·¦å³å››å€‹æ–¹å‘
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dx, dy] of directions) {
                        const newRow = row + dx;
                        const newCol = col + dy;
                        if (newRow >= 0 && newRow < gameBoard.value.length && 
                            newCol >= 0 && newCol < gameBoard.value[0].length) {
                            if (['ğŸ‘¾', 'ğŸ‰'].includes(gameBoard.value[newRow][newCol])) {
                                positions.push([newRow, newCol]);
                            }
                        }
                    }
                    return positions;
                });

                // æ–¹æ³•ï¼šç”Ÿæˆæ•¸å­¸å•é¡Œ
                const generateProblem = () => {
                    const types = [
                        // ç™¾åˆ†æ¯”è¨ˆç®—ï¼ˆä¿®æ­£ç‚º5çš„å€æ•¸ï¼‰
                        {
                            generate: () => {
                                const original = (Math.floor(Math.random() * 18) + 2) * 50; // 100åˆ°900ï¼Œä»¥50ç‚ºæ­¥é€²
                                const discount = (Math.floor(Math.random() * 3) + 7) * 5; // 35, 40, 45æŠ˜
                                const finalPrice = Math.floor(original * discount / 100);
                                return {
                                    question: `æŸå•†å“åŸåƒ¹ ${original} å…ƒï¼Œæ‰“ ${discount} æŠ˜ï¼Œå”®åƒ¹æ˜¯å¤šå°‘å…ƒï¼Ÿ`,
                                    answer: finalPrice,
                                    options: [
                                        finalPrice,
                                        Math.floor(original * (discount - 5) / 100),
                                        Math.floor(original * (discount + 5) / 100),
                                        Math.floor(original * discount / 80)
                                    ].sort(() => Math.random() - 0.5)
                                };
                            }
                        },
                        // å¹¾ä½•é¡Œç›® - ä¸‰è§’å½¢
                        {
                            generate: () => {
                                const angles = [30, 45, 60, 90];
                                const angle1 = angles[Math.floor(Math.random() * angles.length)];
                                const angle2 = angles[Math.floor(Math.random() * angles.length)];
                                const angle3 = 180 - angle1 - angle2;
                                if (angle3 <= 0) return this.generate(); // é‡æ–°ç”Ÿæˆ
                                
                                return {
                                    question: `åœ¨ä¸‰è§’å½¢ABCä¸­ï¼Œ$\angle A = ${angle1}Â°$ï¼Œ$\angle B = ${angle2}Â°$ï¼Œæ±‚$\angle C = ?$`,
                                    answer: angle3,
                                    options: [
                                        angle3,
                                        180 - angle3,
                                        angle1 + angle2,
                                        90
                                    ].sort(() => Math.random() - 0.5)
                                };
                            }
                        },
                        // å¹¾ä½•é¡Œç›® - å¹³è¡Œç·š
                        {
                            generate: () => {
                                const baseAngle = Math.floor(Math.random() * 12) * 5 + 30; // 30åˆ°85åº¦ï¼Œæ­¥é€²5
                                return {
                                    question: `å…©æ¢å¹³è¡Œç·šè¢«ä¸€æ¢ç›´ç·šç›¸äº¤ï¼Œå¦‚æœå…¶ä¸­ä¸€å€‹åŒä½è§’ç‚º ${baseAngle}Â°ï¼Œå‰‡å¦ä¸€å€‹å°æ‡‰çš„åŒä½è§’ç‚ºå¤šå°‘åº¦ï¼Ÿ`,
                                    answer: baseAngle,
                                    options: [
                                        baseAngle,
                                        180 - baseAngle,
                                        90,
                                        baseAngle + 90
                                    ].sort(() => Math.random() - 0.5)
                                };
                            }
                        },
                        // æ–¹ç¨‹å¼ï¼ˆæ”¹é€²ç‰ˆï¼‰
                        {
                            generate: () => {
                                const x = Math.floor(Math.random() * 10) + 1;
                                const a = Math.floor(Math.random() * 5) + 1;
                                const b = Math.floor(Math.random() * 20) + 1;
                                const side = Math.random() < 0.5 ? 'left' : 'right';
                                const equation = side === 'left' 
                                    ? `${a}x + ${b} = ${a * x + b}`
                                    : `${a * x + b} = ${a}x + ${b}`;
                                return {
                                    question: `è§£æ–¹ç¨‹å¼ï¼š${equation}`,
                                    answer: x,
                                    options: [x, x + 1, x - 1, x + 2].sort(() => Math.random() - 0.5)
                                };
                            }
                        },
                        // å¤šé …å¼å› å¼åˆ†è§£
                        {
                            generate: () => {
                                const expressions = [
                                    { question: 'å°‡ä»¥ä¸‹å¤šé …å¼å› å¼åˆ†è§£ï¼š$2x + 6$', answer: '2(x + 3)', options: ['2(x + 3)', '2x + 3', 'x + 6', '2x + 6'] },
                                    { question: 'å°‡ä»¥ä¸‹å¤šé …å¼å› å¼åˆ†è§£ï¼š$x^2 - 16$', answer: '(x - 4)(x + 4)', options: ['(x - 4)(x + 4)', 'x^2 - 4', '(x - 2)(x + 8)', '(x - 8)(x + 2)'] }
                                ];
                                const expr = expressions[Math.floor(Math.random() * expressions.length)];
                                return {
                                    question: expr.question,
                                    answer: expr.answer,
                                    options: expr.options.sort(() => Math.random() - 0.5)
                                };
                            }
                        }
                    ];

                    const type = types[Math.floor(Math.random() * types.length)];
                    return type.generate();
                };
                // æ–¹æ³•ï¼šå›ç­”å•é¡Œ
                let handleAnswer = (selectedOption, event) => {
   
                     clearInterval(timerInterval);
                    timerActive.value = false;
                    showProblem.value = false;

                    if (selectedOption === currentProblem.value.answer) {
                        // ç­”å°
                        if (missionState.target === 'ğŸ‘¾') {
                            const monsterPosition = findMonsterPosition();
                            if (monsterPosition) {
                                const [row, col] = monsterPosition;
                                gameBoard.value[row][col] = 'â¬œ';
                                playerState.exp += monsters['ğŸ‘¾'].exp;
                                playerState.score += 10;
                                alert('ç­”å°äº†ï¼æ“Šæ•—äº†æ€ªç‰©ï¼');
                                checkMissionCompletion();
                                checkLevelUp();
                                checkAndUnlockLevels(playerState.score);
                            }
                        } else if (missionState.target === 'æ‘æ°‘') {
                            const npc = findRescueNPC();
                            if (npc) {
                                rescueNPC(npc);
                            }
                        }
                    } else {
                        // ç­”éŒ¯
                        playerState.hp -= 10;
                        alert('ç­”éŒ¯äº†ï¼å¤±å»10é»ç”Ÿå‘½å€¼ï¼');
                        if (playerState.hp <= 0) {
                            gameState.isGameOver = true;
                            gameState.isWin = false;
                            gameState.message = 'éŠæˆ²çµæŸï¼ç”Ÿå‘½å€¼æ­¸é›¶ï¼';
                        }
                    }

                    // é–‹å§‹æ•µäººå›åˆ
                    if (!gameState.isGameOver) {
                        enemyTurn();
                    }
                };

                // æ–¹æ³•ï¼šåˆå§‹åŒ–é—œå¡
                const initLevel = (levelId) => {
                    const level = LEVELS.find(l => l.id === levelId);
                    if (!level) return;
                    gameState.currentLevel = levelId;
                    gameState.isGameOver = false;
                    gameState.message = '';
                    gameState.showLevelSelect = false;
                    missionState.isCompleted = false;
                    characterState.exp = 0;
                    playerState.hp = characters[characterState.type].hp;
                    playerState.score = 0;
                    playerState.gold = 0;
                    playerState.items = [];
                    gameBoard.value = JSON.parse(JSON.stringify(level.map));
                    monsters['ğŸ‘¾'].hp = 30;
                    monsters['ğŸ‰'].hp = 50;
                    npcs.forEach(npc => { npc.isRescued = false; });
                    initializeMission();
                };

                // æ–¹æ³•ï¼šé¸æ“‡é—œå¡
                const handleLevelSelect = (levelId) => {
                    if (!gameState.unlockedLevels.includes(levelId)) return;
                    initLevel(levelId);
                };

                // æ–¹æ³•ï¼šè™•ç†æ ¼å­é»æ“Š
                const handleCellClick = (row, col) => {
                    if (gameState.isGameOver || showProblem.value) return;
                    
                    const cell = gameBoard.value[row][col];
                    
                    // é¸æ“‡è§’è‰²
                    if (['ğŸ‘¶', 'ğŸ§™â€â™‚ï¸', 'ğŸ§™'].includes(cell)) {
                        selectedPosition.value = [row, col];
                        return;
                    }

                    // ç§»å‹•
                    if (moveablePositions.value.some(pos => pos[0] === row && pos[1] === col)) {
                        // ç§»å‹•è§’è‰²
                        moveCharacter(selectedPosition.value, [row, col]);
                        selectedPosition.value = null;
                        return;
                    }

                    // æ”»æ“Š
                    if (attackablePositions.value.some(pos => pos[0] === row && pos[1] === col)) {
                        // é¸æ“‡æ€ªç‰©æ”»æ“Š
                        selectedPosition.value = [row, col];
                        const problem = generateProblem();
                        currentProblem.value = problem;
                        showProblem.value = true;
                        timerActive.value = true;
                        startTimer();
                        return;
                    }

                    // æ‹¯æ•‘NPC
                    if (isNPCCell(cell)) {
                        const npc = npcs.find(n => n.position[0] === row && n.position[1] === col && !n.isRescued);
                        if (npc) {
                            rescueNPC(npc);
                        }
                        return;
                    }
                };

                // æ–¹æ³•ï¼šç§»å‹•è§’è‰²
                const moveCharacter = (from, to) => {
                    const [fromRow, fromCol] = from;
                    const [toRow, toCol] = to;
                    const character = gameBoard.value[fromRow][fromCol];
                    gameBoard.value[fromRow][fromCol] = 'â¬œ';
                    gameBoard.value[toRow][toCol] = character;
                    playerState.score += 5;
                };

                // æ–¹æ³•ï¼šåˆ¤æ–·æ˜¯å¦ç‚ºNPCæ ¼å­
                const isNPCCell = (cell) => {
                    return ['ğŸ¥'].includes(cell) || npcs.some(npc => npc.position[0] === selectedPosition.value[0] && npc.position[1] === selectedPosition.value[1] && npc.isRescued);
                };

                // æ–¹æ³•ï¼šå°‹æ‰¾éœ€è¦æ‹¯æ•‘çš„NPC
                const findRescueNPC = () => {
                    return npcs.find(npc => !npc.isRescued && gameBoard.value[npc.position[0]][npc.position[1]] === 'ğŸ§‘');
                };

                // æ–¹æ³•ï¼šæ‹¯æ•‘NPC
                const rescueNPC = (npc) => {
                    npc.isRescued = true;
                    gameBoard.value[npc.position[0]][npc.position[1]] = 'ğŸ¥'; // ç”¨é†«é™¢åœ–æ¨™ä»£è¡¨å·²æ•‘å‡ºçš„NPC
                    playerState.exp += 25;
                    playerState.score += 25;
                    playerState.gold += 15;
                    alert(`æˆåŠŸæ•‘å‡º ${npc.name}ï¼ç²å¾—25ç¶“é©—å€¼ã€25åˆ†æ•¸å’Œ15é‡‘å¹£ï¼`);
                    checkLevelUp();
                    checkMissionCompletion();
                    checkAndUnlockLevels(playerState.score);
                };

                // æ–¹æ³•ï¼šæª¢æŸ¥ä»»å‹™å®Œæˆ
                const checkMissionCompletion = () => {
                    const level = LEVELS.find(l => l.id === gameState.currentLevel);
                    if (!level) return;

                    if (level.mission.includes('æ‰“æ•—')) {
                        const defeatedMonsters = Object.values(monsters).filter(m => m.hp <= 0 && m.type === 'goblin');
                        if (defeatedMonsters.length >= missionState.requiredCount) {
                            completeMission();
                        }
                    } else if (level.mission.includes('è§£æ•‘')) {
                        const rescuedNpcs = npcs.filter(npc => npc.isRescued);
                        if (rescuedNpcs.length >= missionState.requiredCount) {
                            completeMission();
                        }
                    }
                };

                // æ–¹æ³•ï¼šå®Œæˆä»»å‹™
                const completeMission = () => {
                    missionState.isCompleted = true;
                    gameState.missionCompleted = true;
                    playerState.exp += 50;
                    playerState.gold += 30;
                    playerState.score += 50;
                    alert('ä»»å‹™å®Œæˆï¼ç²å¾—ç¶“é©—å€¼ã€é‡‘å¹£å’Œåˆ†æ•¸ï¼');
                    checkLevelUp();
                    checkAndUnlockLevels(playerState.score);
                };

                // æ–¹æ³•ï¼šæª¢æŸ¥ä¸¦è§£é–é—œå¡
                const checkAndUnlockLevels = (score) => {
                    LEVELS.forEach(level => {
                        if (score >= level.requiredScore && !gameState.unlockedLevels.includes(level.id)) {
                            gameState.unlockedLevels.push(level.id);
                            alert(`æ­å–œè§£é– ${level.name} é—œå¡ï¼`);
                        }
                    });
                };

                // æ–¹æ³•ï¼šæª¢æŸ¥è§’è‰²æ˜¯å¦å‡ç´š
                const checkLevelUp = () => {
                    if (characterState.exp >= 100 && characterState.type !== 'ğŸ§™') {
                        characterState.type = 'ğŸ§™';
                        characterState.level = 3;
                        effectSystem.addEffect('levelUp', { x: window.innerWidth / 2, y: window.innerHeight / 2 });
                        // æ’­æ”¾å‡ç´šéŸ³æ•ˆ
                        const audio = new Audio('https://example.com/levelup.mp3'); // è«‹æ›¿æ›ç‚ºå¯¦éš›éŸ³æ•ˆURL
                        audio.play();
                        alert('æ­å–œå‡ç´šç‚ºå¤§æ³•å¸«ï¼ç²å¾—æ–°æŠ€èƒ½ï¼šç¯„åœæ”»æ“Šï¼');
                    } else if (characterState.exp >= 50 && characterState.type === 'ğŸ‘¶') {
                        characterState.type = 'ğŸ§™â€â™‚ï¸';
                        characterState.level = 2;
                        effectSystem.addEffect('levelUp', { x: window.innerWidth / 2, y: window.innerHeight / 2 });
                        // æ’­æ”¾å‡ç´šéŸ³æ•ˆ
                        const audio = new Audio('https://example.com/levelup.mp3'); // è«‹æ›¿æ›ç‚ºå¯¦éš›éŸ³æ•ˆURL
                        audio.play();
                        alert('æ­å–œå‡ç´šç‚ºæ³•å¸«å­¸å¾’ï¼ç²å¾—æ–°æŠ€èƒ½ï¼šæš´æ“Šï¼');
                    }
                };

                // æ–¹æ³•ï¼šæ›´æ–°éŠæˆ²æ¿
                const updateGameBoard = (monsterKey) => {
                    gameBoard.value.forEach((row, rowIndex) => {
                        row.forEach((cell, colIndex) => {
                            if (cell === monsterKey) {
                                gameBoard.value[rowIndex][colIndex] = 'â¬œ';
                            }
                        });
                    });
                };

                // æ–¹æ³•ï¼šç²å–ä»»å‹™ç›®æ¨™
                const getMissionObjective = () => {
                    return {
                        mission: missionState.currentMission,
                        requiredCount: missionState.requiredCount,
                        objectives: missionState.objectives,
                        isCompleted: missionState.isCompleted
                    };
                };

                // æ–¹æ³•ï¼šå°‹æ‰¾æ€ªç‰©ä½ç½®
                const findMonsterPosition = (monsterKey) => {
                    for (let r = 0; r < gameBoard.value.length; r++) {
                        for (let c = 0; c < gameBoard.value[r].length; c++) {
                            if (gameBoard.value[r][c] === monsterKey) {
                                return [r, c];
                            }
                        }
                    }
                    return null;
                };

                // æ–¹æ³•ï¼šé–‹å§‹è¨ˆæ™‚
                const startTimer = () => {
                    timer.value = 30;
                    timerActive.value = true;
                    timerInterval = setInterval(() => {
                        if (timer.value > 0) {
                            timer.value -= 1;
                        } else {
                            clearInterval(timerInterval);
                            timerActive.value = false;
                            // å‹•ç­”éŒ¯
                            handleAnswer(null, { clientX: 0, clientY: 0 });
                        }
                    }, 1000);
                };

                // æ–¹æ³•ï¼šæ•µæ–¹å›åˆ
                const enemyTurn = () => {
                    setTimeout(() => {
                        attackPlayer();
                    }, 500);
                };

                // æ–¹æ³•ï¼šæ•µäººæ”»æ“Šç©å®¶
                const attackPlayer = () => {
                    const activeMonsters = Object.values(monsters).filter(m => m.hp > 0);
                    activeMonsters.forEach(monster => {
                        playerState.hp -= monster.damage;
                        alert(`${monster.name} æ”»æ“Šä½ ï¼Œé€ æˆ ${monster.damage} é»å‚·å®³ï¼`);
                        effectSystem.addEffect(monster.type === 'goblin' ? 'fireball' : 'lightning', {
                            x: Math.random() * window.innerWidth,
                            y: Math.random() * window.innerHeight
                        });
                        if (playerState.hp <= 0) {
                            gameState.isGameOver = true;
                            gameState.isWin = false;
                            gameState.message = 'éŠæˆ²çµæŸï¼ç”Ÿå‘½å€¼æ­¸é›¶ï¼';
                        }
                    });
                };

                // ç‰¹æ•ˆç³»çµ±
                const effectSystem = reactive({
                    effects: [],
                    addEffect(type, position) {
                        const effect = {
                            id: Date.now(),
                            type,
                            position,
                            text: type === 'levelUp' ? 'âœ¨' : type === 'heal' ? 'ğŸ’š' : type === 'fireball' ? 'ğŸ”¥' : 'âš¡',
                            style: {
                                left: `${position.x}px`,
                                top: `${position.y}px`,
                                animation: type === 'levelUp' ? 'levelUpEffect 1s ease-out' :
                                           type === 'heal' ? 'healEffect 1s ease-out' :
                                           type === 'fireball' ? 'fireballEffect 0.5s ease-out' :
                                           'lightningEffect 0.5s ease-out'
                            }
                        };
                        effectSystem.effects.push(effect);
                        setTimeout(() => {
                            const index = effectSystem.effects.findIndex(e => e.id === effect.id);
                            if (index > -1) effectSystem.effects.splice(index, 1);
                        }, type === 'levelUp' ? 1000 : type === 'heal' ? 1000 : 500);
                    }
                });

                // æ–¹æ³•ï¼šæ–½æ”¾é­”æ³•
                const castSpell = (spell) => {
                    if (gameState.isGameOver) return;

                    if (spell === 'heal') {
                        if (playerState.hp < characters[characterState.type].hp && playerState.gold >= 10) {
                            playerState.hp += 20;
                            playerState.gold -= 10;
                            alert('ä½ æ–½æ”¾äº†æ²»ç™‚é­”æ³•ï¼Œæ¢å¾©äº†20é»ç”Ÿå‘½å€¼ï¼');
                            effectSystem.addEffect('heal', { x: window.innerWidth / 2, y: window.innerHeight / 2 });
                        } else if (playerState.hp >= characters[characterState.type].hp) {
                            alert('ä½ çš„ç”Ÿå‘½å€¼å·²æ»¿ï¼');
                        } else {
                            alert('é‡‘å¹£ä¸è¶³ï¼');
                        }
                    } else if (spell === 'fireball') {
                        if (playerState.gold >= 20) {
                            playerState.gold -= 20;
                            // éš¨æ©Ÿé¸æ“‡ä¸€å€‹æ€ªç‰©
                            const activeMonsters = Object.keys(monsters).filter(m => monsters[m].hp > 0);
                            if (activeMonsters.length > 0) {
                                const target = activeMonsters[Math.floor(Math.random() * activeMonsters.length)];
                                monsters[target].hp -= 25;
                                alert(`ä½ ä½¿ç”¨äº†ç«çƒè¡“ï¼Œå° ${monsters[target].name} é€ æˆäº†25é»å‚·å®³ï¼`);
                                effectSystem.addEffect('fireball', { x: window.innerWidth / 2, y: window.innerHeight / 2 });
                                if (monsters[target].hp <= 0) {
                                    updateGameBoard(target);
                                    alert(`æ“Šæ•—äº†${monsters[target].name}ï¼`);
                                    playerState.exp += monsters[target].exp;
                                    playerState.score += 10;
                                    checkMissionCompletion();
                                    checkLevelUp();
                                    checkAndUnlockLevels(playerState.score);
                                }
                            } else {
                                alert('æ²’æœ‰å¯æ”»æ“Šçš„æ€ªç‰©ï¼');
                            }
                        } else {
                            alert('é‡‘å¹£ä¸è¶³ï¼');
                        }
                    } else if (spell === 'lightning') {
                        if (playerState.gold >= 30) {
                            playerState.gold -= 30;
                            // æ”»æ“Šæ‰€æœ‰æ€ªç‰©
                            const activeMonsters = Object.keys(monsters).filter(m => monsters[m].hp > 0);
                            if (activeMonsters.length > 0) {
                                activeMonsters.forEach(m => {
                                    monsters[m].hp -= 15;
                                    effectSystem.addEffect('lightning', { x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight });
                                    if (monsters[m].hp <= 0) {
                                        updateGameBoard(m);
                                        alert(`æ“Šæ•—äº†${monsters[m].name}ï¼`);
                                        playerState.exp += monsters[m].exp;
                                        playerState.score += 10;
                                        checkMissionCompletion();
                                        checkLevelUp();
                                        checkAndUnlockLevels(playerState.score);
                                    }
                                });
                                alert('ä½ ä½¿ç”¨äº†é–ƒé›»è¡“ï¼Œå°æ‰€æœ‰æ€ªç‰©é€ æˆäº†15é»å‚·å®³ï¼');
                            } else {
                                alert('æ²’æœ‰å¯æ”»æ“Šçš„æ€ªç‰©ï¼');
                            }
                        } else {
                            alert('é‡‘å¹£ä¸è¶³ï¼');
                        }
                    }
                };

                // è¿”å›æ‰€æœ‰éœ€è¦åœ¨æ¨¡æ¿ä¸­ä½¿ç”¨çš„è®Šæ•¸å’Œæ–¹æ³•
                return {
                    gameBoard,
                    playerState,
                    selectedPosition,
                    moveablePositions,
                    attackablePositions,
                    currentProblem,
                    showProblem,
                    currentMonster,
                    gameState,
                    levels: LEVELS,
                    initLevel,
                    generateProblem,
                    checkAndUnlockLevels,
                    characterState,
                    checkLevelUp,
                    monsters,
                    effectSystem,
                    handleLevelSelect,
                    handleCellClick,
                    handleAnswer,
                    isPlayerCharacter: (cell) => ['ğŸ‘¶', 'ğŸ§™â€â™‚ï¸', 'ğŸ§™'].includes(cell),
                    npcs,
                    missionState,
                    timer,
                    timerActive,
                    rescueNPC,
                    initializeMission,
                    isMonster,
                    castSpell,
                    updateGameBoard,
                    getMissionObjective,
                    checkMissionCompletion,
                    completeMission,
                    characters,
                };
            },
            mounted() {
                // åˆå§‹åŒ–ç¬¬ä¸€é—œ
                this.initLevel(1);
                this.initializeMission();
            },
            template: `
                <div class="game-container">
                    <h1 class="game-title">æ•¸å­¸æˆ°æ£‹</h1>

                    <!-- èªªæ˜é¢æ¿ -->
                    <div class="instructions">
                        <h3>éŠæˆ²èªªæ˜</h3>
                        <p>1. éŠæˆ²é–‹å§‹å‰è«‹é¸æ“‡ä¸€å€‹é—œå¡ã€‚</p>
                        <p>2. é»æ“Šè§’è‰²é¡¯ç¤ºå¯ç§»å‹•çš„ç¶ è‰²æ ¼å­ï¼Œç§»å‹•åˆ°ç›®æ¨™ä½ç½®ã€‚</p>
                        <p>3. ç•¶è§’è‰²ç§»å‹•åˆ°æœ‰æ€ªç‰©çš„æ ¼å­æ™‚ï¼Œå°‡è§¸ç™¼æ•¸å­¸é¡Œç›®ï¼Œç­”å°å³å¯æ”»æ“Šæ€ªç‰©ã€‚</p>
                        <p>4. ç­”éŒ¯å‰‡å¤±å»ç”Ÿå‘½å€¼ï¼Œç”Ÿå‘½å€¼æ­¸é›¶å‰‡éŠæˆ²çµæŸã€‚</p>
                        <p>5. ç´¯ç©ç¶“é©—å€¼å¾Œï¼Œè§’è‰²å¯ä»¥å‡ç´šï¼š</p>
                        <ul>
                            <li>å°å…µ (0-49ç¶“é©—å€¼)ï¼šåŸºæœ¬æ”»æ“Š</li>
                            <li>æ³•å¸«å­¸å¾’ (50-99ç¶“é©—å€¼)ï¼š20%æ©Ÿç‡é€ æˆæš´æ“Š(2å€å‚·å®³)</li>
                            <li>å¤§æ³•å¸« (100ç¶“é©—å€¼ä»¥ä¸Š)ï¼š30%æ©Ÿç‡æš´æ“Šã€æ¯æ¬¡æ”»æ“Šæ¢å¾©10é»ç”Ÿå‘½å€¼</li>
                        </ul>

                        <!-- é­”æ³•é¸å–® -->
                        <div class="magic-menu">
                            <button class="magic-btn" @click="castSpell('heal')">æ²»ç™‚</button>
                            <button class="magic-btn" @click="castSpell('fireball')">ç«çƒè¡“</button>
                            <button class="magic-btn" @click="castSpell('lightning')">é–ƒé›»è¡“</button>
                        </div>
                    </div>

                    <!-- é—œå¡é¸æ“‡ç•«é¢ -->
                    <div v-if="gameState.showLevelSelect">
                        <h2>é¸æ“‡é—œå¡</h2>
                        <div class="level-grid">
                            <div v-for="level in levels" 
                                 :key="level.id"
                                 class="level-card"
                                 :class="{
                                     'locked': !gameState.unlockedLevels.includes(level.id),
                                     'current': gameState.currentLevel === level.id
                                 }"
                                 @click="handleLevelSelect(level.id)"
                                 :disabled="!gameState.unlockedLevels.includes(level.id)">
                                <h3>{{ level.name }}</h3>
                                <p>é›£åº¦ï¼š{{ level.difficulty }}</p>
                                <p v-if="level.requiredScore > 0">
                                    éœ€è¦ {{ level.requiredScore }} åˆ†è§£é–
                                </p>
                            </div>
                        </div>
                        <div class="character-info">
                            <h3>è§’è‰²ç‹€æ…‹</h3>
                            <p>ç­‰ç´šï¼š{{ characterState.level }}</p>
                            <p>ç¶“é©—å€¼ï¼š{{ characterState.exp }}/100</p>
                            <p>è·æ¥­ï¼š{{ characters[characterState.type].name }}</p>
                            <p>é‡‘å¹£ï¼š{{ playerState.gold }}</p>
                            <p>é“å…·ï¼š{{ playerState.items.join(', ') || 'ç„¡' }}</p>
                        </div>
                    </div>

                    <!-- éŠæˆ²é€²è¡Œç•«é¢ -->
                    <div v-else>
                        <div class="status-bar">
                            HP: {{ playerState.hp }} | åˆ†æ•¸: {{ playerState.score }} | é‡‘å¹£: {{ playerState.gold }}
                            <div class="timer" v-if="timerActive">å€’è¨ˆæ™‚ï¼š{{ timer }}</div>
                        </div>
                        <div v-if="gameState.isGameOver" class="game-over">
                            {{ gameState.message }}
                            <button @click="initLevel(gameState.currentLevel)" class="menu-btn">
                                é‡æ–°æŒ‘æˆ°
                            </button>
                        </div>
                        <div class="game-board">
                            <div v-for="(row, rowIndex) in gameBoard" 
                                 :key="rowIndex" 
                                 class="board-row">
                                <div v-for="(cell, colIndex) in row" 
                                     :key="colIndex"
                                     class="board-cell"
                                     :class="{
                                         'selected': selectedPosition && selectedPosition[0] === rowIndex && selectedPosition[1] === colIndex,
                                         'moveable': moveablePositions.some(([r, c]) => r === rowIndex && c === colIndex),
                                         'attackable': attackablePositions.some(([r, c]) => r === rowIndex && c === colIndex)
                                     }"
                                     @click="handleCellClick(rowIndex, colIndex)">
                                    <div class="cell-content">
                                        {{ cell }}
                                        <div v-if="isMonster(cell)" class="health-bar">
                                            <div class="health-bar-fill" 
                                                 :style="{ width: (monsters[cell].hp / monsters[cell].maxHp) * 100 + '%' }">
                                            </div>
                                        </div>
                                        <div v-if="isNPCCell(cell)" class="health-bar">
                                            <div class="health-bar-fill" style="background: #4CAF50;"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button @click="gameState.showLevelSelect = true" class="menu-btn">
                            è¿”å›é¸å–®
                        </button>
                    </div>

                    <!-- å•é¡Œå½ˆçª— -->
                    <div v-if="showProblem" class="problem-modal">
                        <div class="problem-content">
                            <h3>è§£ç­”ä¸‹åˆ—é¡Œç›®ï¼š</h3>
                            <p class="question">{{ currentProblem.question }}</p>
                            <div class="options">
                                <button 
                                    v-for="option in currentProblem.options" 
                                    :key="option"
                                    @click="handleAnswer(option, $event)"
                                    class="option-btn">
                                    {{ option }}
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- è§’è‰²ä¿¡æ¯ -->
                    <div class="character-info">
                        <h3>è§’è‰²ç‹€æ…‹</h3>
                        <p>ç­‰ç´šï¼š{{ characterState.level }}</p>
                        <p>ç¶“é©—å€¼ï¼š{{ characterState.exp }}/100</p>
                        <p>è·æ¥­ï¼š{{ characters[characterState.type].name }}</p>
                        <p>é‡‘å¹£ï¼š{{ playerState.gold }}</p>
                        <p>é“å…·ï¼š{{ playerState.items.join(', ') || 'ç„¡' }}</p>
                    </div>

                    <!-- ç‰¹æ•ˆé¡¯ç¤º -->
                    <div v-for="effect in effectSystem.effects" 
                         :key="effect.id"
                         class="special-effect"
                         :style="effect.style">
                        {{ effect.text }}
                    </div>
                </div>
            `,
        }).mount('#app');
    </script>
</body>
</html>
</html>